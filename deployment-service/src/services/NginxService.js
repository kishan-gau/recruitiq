/**
 * NGINX Service
 * 
 * Manages NGINX configuration for tenant subdomains.
 * Handles creating, enabling, and removing site configurations.
 */

import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

class NginxService {
  constructor(options = {}) {
    this.sshOptions = options.sshOptions || '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null';
    this.sitesAvailable = options.sitesAvailable || '/etc/nginx/sites-available';
    this.sitesEnabled = options.sitesEnabled || '/etc/nginx/sites-enabled';
    this.baseDomain = options.baseDomain || 'recruitiq.nl';
  }

  /**
   * Execute SSH command on VPS
   * @param {string} vpsIp - VPS IP address
   * @param {string} command - Command to execute
   * @param {string} sshKey - Path to SSH private key
   * @returns {Promise<Object>} Command result
   */
  async execSSH(vpsIp, command, sshKey) {
    const sshCmd = `ssh ${this.sshOptions} -i "${sshKey}" root@${vpsIp} "${command}"`;
    
    try {
      const { stdout, stderr } = await execAsync(sshCmd, { timeout: 60000 });
      return { success: true, stdout: stdout.trim(), stderr: stderr.trim() };
    } catch (error) {
      return { 
        success: false, 
        error: error.message, 
        stdout: error.stdout?.trim() || '', 
        stderr: error.stderr?.trim() || '' 
      };
    }
  }

  /**
   * Generate NGINX configuration for a tenant
   * @param {Object} config - Configuration options
   * @returns {string} NGINX configuration content
   */
  generateSiteConfig(config) {
    const { 
      domain,
      organizationSlug,
      backendPort,
      frontendPort,
      enableSSL = false
    } = config;

    const fullDomain = domain || `${organizationSlug}.${this.baseDomain}`;

    // Initial HTTP-only config (SSL will be added by certbot)
    let nginxConfig = `
# NGINX configuration for ${fullDomain}
# Generated by RecruitIQ Deployment Service

# HTTP server - redirect to HTTPS after SSL is configured
server {
    listen 80;
    listen [::]:80;
    server_name ${fullDomain};

    # Security headers for HTTP
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # For certbot webroot challenge
    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }

    # Redirect all other HTTP traffic to HTTPS
    location / {
        return 301 https://\\$server_name\\$request_uri;
    }
}
`;

    // Add HTTPS server block only if SSL is configured
    if (enableSSL) {
      nginxConfig += `
# HTTPS server
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${fullDomain};

    # SSL certificates (managed by certbot)
    ssl_certificate /etc/letsencrypt/live/${fullDomain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${fullDomain}/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Proxy settings
    proxy_http_version 1.1;
    proxy_set_header Upgrade \\$http_upgrade;
    proxy_set_header Connection 'upgrade';
    proxy_set_header Host \\$host;
    proxy_set_header X-Real-IP \\$remote_addr;
    proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto \\$scheme;
    proxy_set_header X-Organization-Slug ${organizationSlug};
    proxy_cache_bypass \\$http_upgrade;

    # Backend API
    location /api {
        proxy_pass http://127.0.0.1:${backendPort};
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # Rate limiting for API
        limit_req zone=api_limit burst=20 nodelay;
    }

    # WebSocket support for real-time features
    location /socket.io {
        proxy_pass http://127.0.0.1:${backendPort};
        proxy_set_header Upgrade \\$http_upgrade;
        proxy_set_header Connection "Upgrade";
    }

    # Frontend application
    location / {
        proxy_pass http://127.0.0.1:${frontendPort};
        
        # Cache static assets
        location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            proxy_pass http://127.0.0.1:${frontendPort};
            expires 30d;
            add_header Cache-Control "public, immutable";
        }
    }

    # Health check endpoint (don't proxy, return directly)
    location /nginx-health {
        access_log off;
        return 200 'healthy';
        add_header Content-Type text/plain;
    }

    # Logging
    access_log /var/log/nginx/${organizationSlug}.access.log combined;
    error_log /var/log/nginx/${organizationSlug}.error.log warn;

    # Error pages
    error_page 502 503 504 /50x.html;
    location = /50x.html {
        root /usr/share/nginx/html;
        internal;
    }
}
`;
    } else {
      // Non-SSL HTTPS config that will be replaced by certbot
      nginxConfig += `
# HTTPS server (will be configured by certbot)
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${fullDomain};

    # Temporary self-signed certificate - will be replaced by certbot
    # ssl_certificate /etc/ssl/certs/ssl-cert-snakeoil.pem;
    # ssl_certificate_key /etc/ssl/private/ssl-cert-snakeoil.key;

    # This block will be configured by certbot --nginx
    location / {
        return 503 'SSL configuration pending';
        add_header Content-Type text/plain;
    }
}
`;
    }

    return nginxConfig;
  }

  /**
   * Create and enable NGINX site configuration
   * @param {Object} config - Site configuration
   * @param {string} vpsIp - VPS IP address
   * @param {string} sshKey - Path to SSH private key
   * @returns {Promise<Object>} Result
   */
  async createSiteConfig(config, vpsIp, sshKey) {
    const { organizationSlug, domain } = config;
    const fullDomain = domain || `${organizationSlug}.${this.baseDomain}`;
    const siteName = fullDomain;
    
    // Generate NGINX config
    const nginxConfig = this.generateSiteConfig({
      ...config,
      domain: fullDomain,
      enableSSL: false // SSL will be configured after certbot runs
    });

    // Write config file
    const configPath = `${this.sitesAvailable}/${siteName}`;
    const writeResult = await this.execSSH(vpsIp, 
      `cat > ${configPath} << 'NGINX_EOF'
${nginxConfig}
NGINX_EOF`, sshKey);

    if (!writeResult.success) {
      throw new Error(`Failed to create NGINX config: ${writeResult.error}`);
    }

    console.log(`[NginxService] Created NGINX config: ${configPath}`);

    // Enable site (symlink to sites-enabled)
    const enableResult = await this.execSSH(vpsIp,
      `ln -sf ${configPath} ${this.sitesEnabled}/${siteName}`, sshKey);

    if (!enableResult.success) {
      throw new Error(`Failed to enable NGINX site: ${enableResult.error}`);
    }

    console.log(`[NginxService] Enabled NGINX site: ${siteName}`);

    // Create log directory
    await this.execSSH(vpsIp, 
      `touch /var/log/nginx/${organizationSlug}.access.log /var/log/nginx/${organizationSlug}.error.log`, 
      sshKey);

    return { 
      success: true, 
      configPath,
      siteName,
      domain: fullDomain 
    };
  }

  /**
   * Test NGINX configuration
   * @param {string} vpsIp - VPS IP address
   * @param {string} sshKey - Path to SSH private key
   * @returns {Promise<Object>} Test result
   */
  async testConfig(vpsIp, sshKey) {
    const result = await this.execSSH(vpsIp, 'nginx -t 2>&1', sshKey);
    
    const isValid = result.success && 
      (result.stdout.includes('syntax is ok') || result.stderr.includes('syntax is ok'));
    
    return {
      success: isValid,
      output: result.stdout || result.stderr
    };
  }

  /**
   * Reload NGINX to apply configuration changes
   * @param {string} vpsIp - VPS IP address
   * @param {string} sshKey - Path to SSH private key
   * @returns {Promise<Object>} Result
   */
  async reload(vpsIp, sshKey) {
    // Test configuration first
    const testResult = await this.testConfig(vpsIp, sshKey);
    if (!testResult.success) {
      throw new Error(`NGINX configuration test failed: ${testResult.output}`);
    }

    // Reload NGINX
    const reloadResult = await this.execSSH(vpsIp, 'nginx -s reload', sshKey);
    
    if (!reloadResult.success) {
      throw new Error(`Failed to reload NGINX: ${reloadResult.error}`);
    }

    console.log('[NginxService] NGINX reloaded successfully');
    return { success: true };
  }

  /**
   * Remove NGINX site configuration
   * @param {string} domain - Full domain name
   * @param {string} vpsIp - VPS IP address
   * @param {string} sshKey - Path to SSH private key
   * @returns {Promise<Object>} Result
   */
  async removeSiteConfig(domain, vpsIp, sshKey) {
    // Remove from sites-enabled
    await this.execSSH(vpsIp, 
      `rm -f ${this.sitesEnabled}/${domain}`, sshKey);

    // Remove from sites-available
    await this.execSSH(vpsIp,
      `rm -f ${this.sitesAvailable}/${domain}`, sshKey);

    console.log(`[NginxService] Removed NGINX config for: ${domain}`);

    // Reload NGINX
    await this.reload(vpsIp, sshKey);

    return { success: true };
  }

  /**
   * Update NGINX config with SSL settings
   * @param {Object} config - Site configuration
   * @param {string} vpsIp - VPS IP address
   * @param {string} sshKey - Path to SSH private key
   * @returns {Promise<Object>} Result
   */
  async updateWithSSL(config, vpsIp, sshKey) {
    const fullConfig = {
      ...config,
      enableSSL: true
    };
    
    return this.createSiteConfig(fullConfig, vpsIp, sshKey);
  }

  /**
   * List all configured sites
   * @param {string} vpsIp - VPS IP address
   * @param {string} sshKey - Path to SSH private key
   * @returns {Promise<Array>} List of site names
   */
  async listSites(vpsIp, sshKey) {
    const result = await this.execSSH(vpsIp,
      `ls -1 ${this.sitesEnabled} 2>/dev/null`, sshKey);
    
    if (!result.success || !result.stdout) {
      return [];
    }

    return result.stdout.split('\n').filter(s => s.trim());
  }

  /**
   * Check if a site is configured
   * @param {string} domain - Domain name
   * @param {string} vpsIp - VPS IP address
   * @param {string} sshKey - Path to SSH private key
   * @returns {Promise<boolean>} True if site exists
   */
  async siteExists(domain, vpsIp, sshKey) {
    const result = await this.execSSH(vpsIp,
      `test -f ${this.sitesEnabled}/${domain} && echo "exists"`, sshKey);
    
    return result.stdout === 'exists';
  }

  /**
   * Get NGINX status
   * @param {string} vpsIp - VPS IP address
   * @param {string} sshKey - Path to SSH private key
   * @returns {Promise<Object>} NGINX status
   */
  async getStatus(vpsIp, sshKey) {
    const statusResult = await this.execSSH(vpsIp,
      'systemctl is-active nginx 2>/dev/null || echo "inactive"', sshKey);
    
    const sites = await this.listSites(vpsIp, sshKey);
    
    return {
      status: statusResult.stdout || 'unknown',
      isRunning: statusResult.stdout === 'active',
      configuredSites: sites.length,
      sites
    };
  }
}

export default NginxService;
